---
typora-copy-images-to: images
---

> 模型评估标准的核心其实就是衡量一个模型的好坏，合适的评价指标可以帮助我们准确地衡量模型的性能，从而进行优化和改进。

## 1.分类模型评价指标

![](https://img.simoniu.com/分类算法模型评估标准01.png)

在模型评估中，有多个标准用于衡量模型的性能，这些标准包括准确率（Accuracy）、精确率（Precision）、召回率（Recall）、F1 分数（F1-Score）等。

**真正例（True Positive, TP）**

定义 ：模型正确地预测为正类的样本数量。
通俗解释 ：假设你有一个垃圾邮件分类器，它会把邮件标记为垃圾邮件或非垃圾邮件。真正例就是那些被正确标记为垃圾邮件的邮件数量。

例子 ：
你有 100 封邮件。
其中 30 封是垃圾邮件。
模型正确地将 25 封垃圾邮件标记为垃圾邮件。
那么 TP = 25。

**真负例（True Negative, TN）**

定义 ：模型正确地预测为负类的样本数量。
通俗解释 ：假设你有一个垃圾邮件分类器，它会把邮件标记为垃圾邮件或非垃圾邮件。真负例就是那些被正确标记为非垃圾邮件的邮件数量。

例子 ：
你有 100 封邮件。
其中 70 封是非垃圾邮件。
模型正确地将 60 封非垃圾邮件标记为非垃圾邮件。
那么 TN = 60。

**假正例（False Positive, FP）**

定义 ：模型错误地预测为正类的样本数量。
通俗解释 ：假设你有一个垃圾邮件分类器，它会把邮件标记为垃圾邮件或非垃圾邮件。假正例就是那些被错误地标记为垃圾邮件的非垃圾邮件数量。

例子 ：
你有 100 封邮件。
其中 70 封是非垃圾邮件。
模型错误地将 10 封非垃圾邮件标记为垃圾邮件。
那么 FP = 10。

**假负例（False Negative, FN）**

定义 ：模型错误地预测为负类的样本数量。
通俗解释 ：假设你有一个垃圾邮件分类器，它会把邮件标记为垃圾邮件或非垃圾邮件。假负例就是那些被错误地标记为非垃圾邮件的垃圾邮件数量。

例子 ：
你有 100 封邮件。
其中 30 封是垃圾邮件。
模型错误地将 5 封垃圾邮件标记为非垃圾邮件。
那么 FN = 5。

**总结：**
- 真正例（TP） ：模型正确预测为正类的样本数量。
- 真负例（TN） ：模型正确预测为负类的样本数量。
- 假正例（FP） ：模型错误预测为正类的样本数量。
- 假负例（FN） ：模型错误预测为负类的样本数量。

这些概念是评估分类模型性能的基础，通过这些指标可以计算出准确率、精确率、召回率等更高级的评估指标。

## 2.准确率

准确率（Accuracy）准确率是最直观的评估指标，它表示模型预测正确的样本占总样本的比例。计算公式为：

![](https://img.simoniu.com/模型评估准确率01.png)

准确率简单易懂，但在类别不平衡的数据集中可能不够敏感。例如，在一个大多数样本都属于同一类别的数据集中，即使模型将所有样本都分类为这一多数类别，也能获得一个看似不错的准确率，但这并不意味着模型具有很好的区分能力。

```python
from sklearn.metrics import confusion_matrix,accuracy_score
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# 假设我们有以下真实标签和预测结果
y_true = np.array([2, 0, 2, 2, 0, 1])
y_pred = np.array([0, 0, 2, 2, 0, 2])

# 计算准确率
accuracy = accuracy_score(y_true, y_pred)
print("准确率：", accuracy)
```
运行结果：

```xml
准确率： 0.6666666666666666
```

## 3.精确率（Precision）

精确率衡量模型预测为正类的实例中，实际为正类的比例。计算公式为：

![](https://img.simoniu.com/模型评估精准率01.png)

对应多分类问题，采样宏平均精确率是每个类别的精确率的平均值，不考虑每个类别的样本数量。计算公式如下：

![](https://img.simoniu.com/模型评估精准率02.png)

**精确率评估模型 “预测正例的可靠性”。**在信息检索和许多其他领域中，精确率是一个重要的指标，因为它告诉我们检索结果的相关性有多高。一个高精确率意味着模型预测为正类的样本中，绝大多数实际上是正类。

```python
from sklearn.metrics import confusion_matrix,accuracy_score,precision_score
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# 假设我们有以下真实标签和预测结果
y_true = np.array([2, 0, 2, 2, 0, 1])
y_pred = np.array([0, 0, 2, 2, 0, 2])

# 计算精确率
precision = precision_score(y_true, y_pred, average='macro')
print("精确率：", precision)
```

运行结果：
```xml
精确率： 0.4444444444444444
```

## 4.召回率（Recall）

召回率衡量所有实际为正类的样本中，模型预测为正类的比例。计算公式为：

![](https://img.simoniu.com/模型评估召回率01.png)

**召回率评估模型 “捕捉正例的完整性”。**在某些领域，如医疗诊断，召回率尤其重要，因为漏诊（假负例）的后果可能非常严重。

```python
from sklearn.metrics import confusion_matrix,accuracy_score,precision_score,recall_score
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# 假设我们有以下真实标签和预测结果
y_true = np.array([2, 0, 2, 2, 0, 1])
y_pred = np.array([0, 0, 2, 2, 0, 2])

# 计算召回率
recall = recall_score(y_true, y_pred, average='macro')
print("召回率：", recall)
```

运行结果：

```xml
召回率： 0.5555555555555555
```

## 5.F1 分数（F1-Score)

F1分数是精确率和召回率的调和平均值，它平衡了这两个指标。计算公式为：

![](https://img.simoniu.com/模型评估F1分数01.png)

F1分数在精确率和召回率都较高的算法上表现出色。它是一个综合指标，特别适用于那些对精确率和召回率都同样重视的场景。

```python
from sklearn.metrics import confusion_matrix,accuracy_score,precision_score,recall_score,f1_score
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# 假设我们有以下真实标签和预测结果
y_true = np.array([2, 0, 2, 2, 0, 1])
y_pred = np.array([0, 0, 2, 2, 0, 2])

# 计算准确率
accuracy = accuracy_score(y_true, y_pred)
print("准确率：", accuracy)

# 计算精确率
precision = precision_score(y_true, y_pred, average='macro')
print("精确率：", precision)

# 计算召回率
recall = recall_score(y_true, y_pred, average='macro')
print("召回率：", recall)

# 计算F1分数
f1 = f1_score(y_true, y_pred, average='macro')
print("F1分数：", f1)
```

运行结果：
```xml
准确率： 0.6666666666666666
精确率： 0.4444444444444444
召回率： 0.5555555555555555
F1分数： 0.48888888888888893
```


## 6.混淆矩阵

混淆矩阵是评估分类问题的基础工具，它是一个表格，显示了分类算法的预测结果与真实标签之间的关系。对于二分类问题，混淆矩阵包含真正例（TP）、真负例（TN）、假正例（FP）和假负例（FN）。这些值是计算其他评估指标的基础。混淆矩阵不仅提供了一个直观的视觉表示，还允许我们深入了解模型在各个类别上的表现，特别是当处理不平衡数据集时，混淆矩阵可以揭示模型是否倾向于错误地将一个类别分类为另一个类别。

```python
from sklearn.metrics import confusion_matrix,accuracy_score,precision_score,recall_score,f1_score
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# 假设我们有以下真实标签和预测结果
y_true = np.array([2, 0, 2, 2, 0, 1])
y_pred = np.array([0, 0, 2, 2, 0, 2])

# 计算准确率
accuracy = accuracy_score(y_true, y_pred)
print("准确率：", accuracy)

# 计算精确率
precision = precision_score(y_true, y_pred, average='macro')
print("精确率：", precision)

# 计算召回率
recall = recall_score(y_true, y_pred, average='macro')
print("召回率：", recall)

# 计算F1分数
f1 = f1_score(y_true, y_pred, average='macro')
print("F1分数：", f1)

# 计算混淆矩阵
cm = confusion_matrix(y_true, y_pred)

# 使用Seaborn的heatmap函数来可视化混淆矩阵
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted labels')
plt.ylabel('True labels')
plt.title('Confusion Matrix')
plt.show()
```

![](https://img.simoniu.com/模型评估的混淆矩阵01.png)

混淆矩阵是一个强大的工具，它通过展示模型预测结果与实际结果之间的对比，帮助我们直观地了解模型的分类效果。通过分析混淆矩阵，我们可以评估模型的总体表现、各类别的预测准确性、处理类别不平衡问题以及识别模型的错误类型，从而对模型进行改进和优化。

## 7.ROC曲线和AUC值

ROC曲线是一个性能度量，显示了在不同阈值设置下模型的真正例率（召回率）和假正例率的关系。AUC值表示ROC曲线下的面积，用于衡量模型的整体性能，AUC值越高，模型性能越好。ROC曲线和AUC值是评估模型区分不同类别能力的重要工具，尤其在二分类问题中非常实用。

```python
from sklearn.metrics import roc_curve, roc_auc_score
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
import matplotlib.pyplot as plt
import numpy as np

# 假设我们有一个数据集
X = np.array([[0, 0], [1, 1], [2, 0], [2, 2], [0, 1]])
y = np.array([1, 1, 0, 1, 0])

plt.scatter(X[y == 0, 0], X[y == 0, 1], color='red', label='Class 0')
plt.scatter(X[y == 1, 0], X[y == 1, 1], color='blue', label='Class 1')
plt.xlabel('Feature 1')
plt.ylabel('Feature 2')
plt.legend()
plt.title('Data Points by Class')
plt.grid(True)
plt.show()

# 划分训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4, random_state=42)

print("--------训练样本-----------")
print(X_train,y_train)
print("--------测试样本-----------")
print(X_test,y_test)

# 训练一个随机森林分类器
clf = RandomForestClassifier(n_estimators=100, random_state=42)
clf.fit(X_train, y_train)

# 预测概率
y_scores = clf.predict_proba(X_test)[:, 1]

# 计算ROC曲线和AUC值
fpr, tpr, thresholds = roc_curve(y_test, y_scores)
auc = roc_auc_score(y_test, y_scores)

# 绘制ROC曲线
plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()
```

AUC 是 ROC 曲线下方的面积，是一个 标量值，用来衡量分类器的整体性能：

- AUC = 1.0：完美分类器，TPR 始终为 1，FPR 始终为 0；
- AUC = 0.5：等同于随机猜测，ROC 曲线和蓝色对角线重合；
- AUC < 0.5：模型表现差，甚至比随机还差；
- AUC > 0.5：模型有预测能力；
- 通常 AUC 越大，模型性能越好。

运行效果：

![](https://img.simoniu.com/模型评估ROC曲线和AUC值02.png)

## 8.训练过程指标可视化

一般在训练模型的过程中我们需要打印一些数据的图像，例如随着训练轮次的增加损失的变化，或是准确率的变化，亦或者我们想要输出一份模型的混淆矩阵等等。这个过程中不可避免的需要使用一些绘图工具，例如matplotlib。

下面，会介绍一个torch.utils模块中的一个工具（需要pip安装），专门用于实现上述指标的可视化（画图）。

### Tensor Board

[官方文档]( https://pytorch.org/docs/stable/tensorboard.html)

安装：安装的是执行指令，是一个本地化的服务器

```bash
pip install tensorboard
```

在训练完成后，查看训练结果，在当前目录下，打开控制台窗口：

```bash
tensorboard --logdir=runs	
# '='后面填的是日志保存路径
# 运行时，默认会扫描整个目录并合并所有日志(同一标签的画进同一张图)
```

控制台会提示一个访问地址，用浏览器直接访问即可。

#### 使用实例1：绘制损失、准确率随轮次变化的曲线图

```python
# 导入工具
from torch.utils.tensorboard import SummaryWriter
import torch

# 指定tensorboard日志保存路径：统一路径可以指定多个实例对象
writer = SummaryWriter("tensorboard")
"""
class SummaryWriter(
    log_dir: Any | None = None, # 日志保存路径
    comment: str = "",          # 日志的注释，会显示在图表的Run指标下
)
"""


acc = torch.tensor([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])
loss = torch.tensor([1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1])
epoch = torch.tensor([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

for i in range(len(epoch)):

    # 记录训练数据到可视化面板
    writer.add_scalar("Loss/train", loss[i], epoch[i])
    writer.add_scalar("Accuracy/train", acc[i], epoch[i])
    # 在一张图上画两条曲线
    writer.add_scalars("Loss_and_Accuracy/train", {"loss": loss[i], "acc": acc[i]}, epoch[i])
    """
    这个方法会根据传入的‘标签名’确定数据画在哪一张画布上
    """

# 训练完成后记得关闭
writer.close()
```

上面代码运行结果展示：

![1753776034899](images/1753776034899.png)

**Relative：表示当前步骤与第一个步骤的时间差，单位：s**

#### 使用实例2：添加训练时使用的图片

```python
import torch
import torchvision
from torch.utils.tensorboard import SummaryWriter
from torchvision import datasets, transforms

# 这个对象可以不指定路径，默认：./runs
writer = SummaryWriter()

# 定义训练集
transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.5,), (0.5,))])
trainset = datasets.MNIST('data', train=True, download=True, transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=64, shuffle=True)
# 定义模型
model = torchvision.models.resnet50(weights=None)
model.conv1 = torch.nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3, bias=False)
# 将一个批次的图片张量组装为一张图片
images, labels = next(iter(trainloader))
grid = torchvision.utils.make_grid(images)

# 写入刚刚拼接好的图片
writer.add_image('images', grid, 0)
# 写入模型(第二个参数是模型的输入示例【可选】)
writer.add_graph(model, images)
writer.close()
```



## 9.为分类模型生成性能报告

使用 **classification_report** 为分类模型生成性能报告

```python
import numpy as np
from sklearn.metrics import classification_report

# 模拟一套样本的真实标签和预测标签
y_true = np.random.randint(0, 10, size=(10000,))
y_pred = np.random.randint(0, 10, size=(10000,))

# 根据预测值和真实值生成分类报告
report = classification_report(
    y_true,			# 样本的真实标签
    y_pred,			# 样本的预测标签
    target_names=[	# 【可选】类别名称(不传入的话会从0开始为类别标号)
        "class1",
        "class2",
        "class3",
        "class4",
        "class5",
        "class6",
        "class7",
        "class8",
        "class9",
        "class10",
    ],
)
print(report)
```

![输出图片](images/image-20250801195019016.png)



