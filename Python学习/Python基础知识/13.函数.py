# 当函数作为参数传入另一个函数时，不要带括号
# 函数名后面加括号代表运行函数，不加括号代表这个函数本身


"""
函数式编程思想:
    封装 --- 函数本身
    继承 --- 将核心逻辑提取出来封装为一个或者多个函数，将这些函数作为参数传入原函数
    多态 --- 可能会将核心逻辑封装为多个函数，由这些函数共同作用得到结果
"""


# 定义函数(使用关键字def)
"""
# 函数的形参定义自左至右的顺序为：
    def 函数名(仅限位置参数（'/'前面的参数），/，位置参数，默认参数，可变位置参数，仅限关键字参数（*或者*args后面的参数），可变关键字参数)
# 仅限关键字参数只能通过关键字传参，仅限关键字参数也可以设置默认值（但是没有顺序限制）
# 仅限位置参数只能通过位置传参（这个语法需要 python3.8+）
# 位置参数（默认参数就是带默认值的位置参数）既可以通过位置传参，也可以通过关键字传参

def 函数名(参数1, 参数2, 参数3='默认值'):     # 可以把函数设置成不需要参数，也可以设置多个参数，设置默认值时等号两边不要留空白
    函数体                                 
    return 返回值                           # return语句用于返回一个值，且return语句会结束函数的运行(函数可以不返回值)

def 函数名(参数1, 参数2, *形参名):      # '*'会生成一个元组, 这个元组会接收传入的所有多余实参(不限制数量)
    函数体                                     

def 函数名(参数1, 参数2, **形参名):     # '**'会生成一个字典, 给这个字典传参数时需要按照用dict()创建字典时的格式(不限制数量)
    函数体

def 函数名(参数1, /, *, 参数2):     # / 符号前的参数强制用位置传参，* 符号后的参数强制用关键字传参('*形参名'这个地方的星号也是星号)
    函数体
    
注意：调用函数时只有两种传参方式：位置传参和关键字传参（关键字传参必须在位置传参之后）
"""


# 形参和实参
"""
形参与实参的区别：
    函数名后定义的参数叫 形参
    我们向函数传递的具体参数叫 实参

位置实参 & 关键字实参
    调用函数时，实参如果与形参按照顺序一一对应，这种实参叫位置实参
    位置实参的顺序很重要，搞错顺序很可能会导致函数调用出错

    关键值实参是传递给函数的名值对                          # 使用关键值形参时等号左右两边不带空号
    关键值实参就是在调用函数时直接给形参赋值

注意：实参可以是可变数据类型，也可以是不可变数据类型；实参如果是可变数据类型，那么在函数中修改它时，实参本身也会被修改
"""


# 匿名函数(lambda 关键字)
"""
格式: lanmbda 参数：表达式

示例: 
square = lambda x: x ** 2
"""


# 生成器 && 迭代器
"""
可迭代：指对象中的元素可以被遍历（即逐个访问其中的元素）

生成器：
    用 yield 关键字返回数据的函数就是生成器
    每当函数执行到yield关键字返回结果后，函数就会暂停，等待下一次调用时从当前位置继续执行

    生成器是可迭代的，且可以调用next()方法获取下一个值

迭代器：
    可迭代对象：实现了 __iter__() 方法的对象（如列表、字符串）
    迭代器：实现了 __iter__() 和 __next__() 方法的对象
    __iter__()方法：返回迭代器对象
    __next__()方法：返回下一个元素，如果没有更多元素，抛出 StopIteration 异常
"""


# 闭包
"""
    闭包三大要素：
        内部函数
        访问外部函数变量
        返回内部函数
    作用：
        外部函数执行过后 栈帧不会被释放 等待内部函数调用
    优点：逻辑连续，当闭包作为另一个函数调用参数时，避免脱离当前逻辑而单独编写额外逻辑。
    缺点：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包
        
闭包连续性案例：
def give_money(money):
    print('给你%d元'%money)
    
    def buy_thing(thing,price):
        nonlocal money
        money -= price
        print('你购买了%s,还剩%d元'%(thing,money))
    
    return buy_thing

buy_thing = give_money(1000)
buy_thing('书',500)
buy_thing('水果',100)
buy_thing('水果',100)

"""


# 装饰器
"""
# 装饰器是一个函数或类，主要作用是来用包装另一个函数、类方法或类本身
# 系统在执行带装饰器的函数时，会抛弃原本函数的运行逻辑，执行装饰器函数中的运行逻辑
# 需要注意，自定义装饰器函数时，需要把装饰器函数定义在使用装饰器的函数上面

# -----------这是基本装饰器----------------
from time import time 

def new_fun(fn):                    # 装饰器这里的形参必加，这个形参会接收原函数整体
    print("hhhhhh")
    def wrapper(*args,**kwargs):    # 约定成俗装饰器中的内置函数叫wrapper
        start = time()
        print(fn(*args,**kwargs))
        end = time() - start
        print("执行时间：", end)
        return "内置函数返回语句"
    return wrapper    # 这里不要加括号，加了括号代表直接执行这个函数，拿不到外面传入的参数
        
@new_fun              # 加装饰器原理：原函数整体传给装饰器(不包括参数)，参数会传给内置函数
def old_fun(*args):   # 加入装饰器后原函数本身就拿不到传入的参数了，原函数只能去装饰器的内置函数中拿参数
    print(args)
    return sum(args)
    
    
print(old_fun(1, 2, 3, 45, 66, 77, 42))
print(old_fun(1, 2, 3, 45, 66, 77, 42))
# 调用被装饰的函数时，只执行装饰器函数返回的函数



# 带参数的装饰器（这个一般是三层嵌套函数，最外层返回装饰器，中间返回内置函数）
def repeat(num):        # 这里接收装饰器参数
    def decorator(func):        # 这里接收原函数
        def wrapper(*args, **kwargs):       # 这里接收原函数的参数
            for _ in range(num):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)  
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")  # 调用被装饰的函数
greet("Alice")  # 调用被装饰的函数
# 与基本装饰器一样的逻辑，所有外层代码都只执行一次，接下来再次调用原函数就会只会执行装饰器返回的内置函数


注意：普通参数装饰器会在 编译原函数函数 时执行一次，带参数的装饰器函数会在 编译装饰器语句 和 原函数 时各执行一次
    这样保证之后调用原函数时，原函数已经被装饰器内部的内置函数替代


# 类装饰器
class MyDecorator:
    def __init__(self, func):   # 需要在这里接收原函数
        self.func = func

    def __call__(self, *args, **kwargs):    # 原函数的参数回传到这里，每次调用原函数都只会执行这个函数
        print("Something is happening before the function is called.")
        result = self.func(*args, **kwargs)
        print("Something is happening after the function is called.")
        return result

@MyDecorator  # 应用类装饰器
def say_hello(name):
    print(f"Hello, {name}!")

say_hello("Charlie")  # 调用被装饰的函数


# 多个装饰器执行顺序：从下往上（装饰器链）
"""


# 特别注意当你用自己写的装饰器去装饰类时，一定要在内置函数中把生成的类的实例返回

