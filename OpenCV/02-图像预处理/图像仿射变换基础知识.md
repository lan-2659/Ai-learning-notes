



# 图像仿射变换基础知识  


## 1 仿射变换的基本性质  
仿射变换（Affine Transformation）是一种保持几何对象“平直性”的线性变换，其核心特性可概括为：  
- **直线保持性**：变换前的直线段在变换后仍为直线段（无穷远点除外）。  
- **平行性不变**：两条平行直线变换后仍保持平行，且平行线间的距离比例关系不变。  
- **比例不变性**：同一直线上任意三点的简单比（线段比例）在变换后保持不变。  
- **仿射不变量**：面积比、重心位置等在仿射变换中保持不变，但角度、长度、面积绝对值可能改变。  

**几何意义**：仿射变换可看作“线性变换 + 平移”的组合，本质是坐标系的基向量变换与原点平移，不改变空间的线性结构。


## 2 常见的仿射变换类型  
### 2.1 基础变换操作  
| 变换类型   | 几何效果                                  | 物理意义示例          |
| ------ | ------------------------------------- | --------------- |
| **旋转** | 绕指定点逆时针/顺时针转动θ角度，改变对象方向               | 图像校正、目标姿态调整     |
| **平移** | 沿x/y轴平移固定距离，不改变形状大小                   | 图像位置调整、拼图预处理    |
| **缩放** | 沿x/y轴按比例因子放大/缩小，可等比例（各向同性）或非等比例（各向异性） | 图像分辨率调整、目标尺寸归一化 |
| **剪切** | 沿x/y轴方向倾斜变形，形成平行四边形（面积不变）             | 图像透视矫正前的倾斜预处理   |
| **镜像** | 沿x轴或y轴翻转，等价于缩放因子为-1的特殊缩放              | 图像水平/垂直翻转       |

### 2.2 复合变换  
通过基础变换的矩阵乘法组合，可实现复杂变换（如先旋转后缩放，或先剪切后平移），需注意变换顺序对结果的影响。


## 3 仿射变换的数学原理  
### 3.1 齐次坐标与变换矩阵  
在二维空间中，点坐标 $$ (x, y) $$ 的齐次坐标表示为 $$[x, y, 1]^T $$，仿射变换可表示为3×3矩阵与齐次坐标的乘法：  
$$
\underbrace{\begin{bmatrix}x' \\ y' \\ 1\end{bmatrix}}_{\text{目标坐标}} = 
\underbrace{\begin{bmatrix}a & b & t_x \\ c & d & t_y \\ 0 & 0 & 1\end{bmatrix}}_{\text{仿射变换矩阵 } \mathbf{M}} 
\underbrace{\begin{bmatrix}x \\ y \\ 1\end{bmatrix}}_{\text{原坐标}}
$$
#### 仿射变换矩阵分块解析  

仿射变换矩阵采用齐次坐标表示为 $$ 3×3 $$ 矩阵，可分为 **线性变换块**（2×2矩阵）和 **平移向量**（第三列）两部分，具体解析如下：  


#### 1. 线性变换块（左上角 2×2 矩阵，记为 $ \mathbf{L} $）  
$$
\mathbf{L} = \begin{bmatrix}a & b \\ c & d\end{bmatrix}
$$
线性变换块控制图像的 **缩放、旋转、剪切** 等基础变换，不同操作对应不同的参数设置：  

##### 1.1 缩放（Scaling）  
- **非等比例缩放**：  
  - $$ a = s_x $$（x 轴缩放因子，如 $$s_x=0.5 $$ 表示宽度减半）  
  - $$ d = s_y $$（y 轴缩放因子，如 $$s_y=1.5 $$ 表示高度放大1.5倍）  
  - $$ b = c = 0 $$（无剪切）  
- **等比例缩放**：  
  - $$ a = d = s $$（x、y 轴缩放因子相同，如 $$s=2 $$ 表示整体放大2倍）  
- **矩阵形式**：  
  $$
  \mathbf{L}_{\text{scale}} = \begin{bmatrix}s_x & 0 \\ 0 & s_y\end{bmatrix}
  $$


##### 1.2 旋转（Rotation）  
- **绕原点逆时针旋转 $$\theta $$ 角度**：  
  - $$ a = \cos\theta $$，$$b = -\sin\theta $$  
  - $$ c = \sin\theta $$，$$d = \cos\theta $$  
- **几何意义**：  
  - 每个点 $$ (x, y) $$ 绕原点旋转 $$\theta $$ 后，新坐标为：  
    $$
    \begin{cases}
    x' = x\cos\theta - y\sin\theta \\
    y' = x\sin\theta + y\cos\theta
    \end{cases}
    $$

- **矩阵形式**：  
  $$
  \mathbf{L}_{\text{rotate}} = \begin{bmatrix}\cos\theta & -\sin\theta \\ \sin\theta & \cos\theta\end{bmatrix}
  $$


##### 1.3 剪切（Shearing）  
剪切变换使图像产生倾斜，分为 **x 轴剪切** 和 **y 轴剪切**，参数与剪切角的关系如下：  

- **沿 x 轴剪切（y 坐标影响 x 偏移）**：  
  - 剪切角为 $$ \alpha $$（图像沿 x 轴倾斜的角度），则 $$b = \tan\alpha $$  
  - 几何意义：每个点的 x 坐标偏移量为 $$ y \cdot \tan\alpha $$，y 坐标不变  
  - **矩阵形式**：  
    $$
    \mathbf{L}_{\text{shear-x}} = \begin{bmatrix}1 & \tan\alpha \\ 0 & 1\end{bmatrix}
    $$

  - **示例**：当 $$ \alpha = 30^\circ $$ 时，$$b = \tan30^\circ \approx 0.577 $$，图像沿 x 轴向上倾斜。  

- **沿 y 轴剪切（x 坐标影响 y 偏移）**：  
  - 剪切角为 $$ \beta $$（图像沿 y 轴倾斜的角度），则 $$c = \tan\beta $$  
  - 几何意义：每个点的 y 坐标偏移量为 $$ x \cdot \tan\beta $$，x 坐标不变  
  - **矩阵形式**：  
    $$
    \mathbf{L}_{\text{shear-y}} = \begin{bmatrix}1 & 0 \\ \tan\beta & 1\end{bmatrix}
    $$

  - **示例**：当 $$ \beta = 45^\circ $$ 时，$$c = \tan45^\circ = 1 $$，图像沿 y 轴向右倾斜。  


#### 2. 平移向量（第三列，记为 $ \mathbf{t} $）  
$$
\mathbf{t} = \begin{bmatrix}t_x \\ t_y\end{bmatrix}
$$
- **作用**：控制图像整体位移，实现“先线性变换，后平移”的组合操作。  
- **数学表达**：  
  变换后的坐标为 $$ (x', y') = (x \cdot a + y \cdot b + t_x, \ x \cdot c + y \cdot d + t_y) $$，即：  
  $$
  \begin{bmatrix}x' \\ y'\end{bmatrix} = \mathbf{L} \begin{bmatrix}x \\ y\end{bmatrix} + \mathbf{t}
  $$

- **物理意义**：  
  - $$ t_x > 0 $$：图像向右平移 $$t_x $$ 像素；$$t_x < 0 $$：向左平移。  
  - $$ t_y > 0 $$：图像向下平移 $$t_y $$ 像素；$$t_y < 0 $$：向上平移。  


#### 3. 完整仿射变换矩阵的组合  
将线性变换块和平移向量整合到齐次坐标中，得到完整的仿射变换矩阵：  
$$
\mathbf{M} = \begin{bmatrix}\mathbf{L} & \mathbf{t} \\ 0 \ 0 & 1\end{bmatrix} = \begin{bmatrix}a & b & t_x \\ c & d & t_y \\ 0 & 0 & 1\end{bmatrix}
$$
- **变换顺序**：先执行线性变换（缩放/旋转/剪切），再执行平移，确保平移不影响线性变换的中心（如旋转中心需通过平移矩阵调整）。  
- **OpenCV 实现**：  
  - 旋转、平移等组合变换可通过矩阵乘法实现（如 `M = M_translate @ M_rotate`），需注意矩阵乘法顺序（后执行的变换矩阵先相乘）。  


#### 总结  
| 变换类型    | 线性变换块参数                                  | 平移向量             |
| ------- | ---------------------------------------- | ---------------- |
| 缩放      | $$ a=s_x, d=s_y, b=c=0 $$                | 通常为 $$ (0, 0) $$ |
| 旋转（绕原点） | $$ a=\cos\theta, b=-\sin\theta, c=\sin\theta, d=\cos\theta $$ | 需额外平移以调整旋转中心     |
| 沿 x 轴剪切 | $$ b=\tan\alpha, a=d=1, c=0 $$           | 通常为 $$ (0, 0) $$ |
| 沿 y 轴剪切 | $$ c=\tan\beta, a=d=1, b=0 $$            | 通常为 $$ (0, 0) $$ |
| 平移      | $$ a=d=1, b=c=0 $$                       | $$ (t_x, t_y) $$ |

通过调整线性变换块和平移向量的参数，可组合出复杂的仿射变换效果（如先旋转后平移、先缩放后剪切等）。



### 3.2 OpenCV核心函数：`cv2.warpAffine()`  
```python  
cv2.warpAffine(
    src,        # 输入图像（单/三通道，数据类型需为uint8或float32）
    M,          # 2×3变换矩阵（必须为np.float32类型）
    dsize,      # 输出图像尺寸（宽, 高），需根据变换调整避免截断
    flags=cv2.INTER_LINEAR,  # 插值方法：
                             # - INTER_NEAREST（最近邻，速度快）
                             # - INTER_LINEAR（双线性，默认，平衡质量）
                             # - INTER_AREA（区域插值，缩放时抗锯齿）
                             # - INTER_CUBIC（双三次，高质量但慢）
    borderMode=cv2.BORDER_CONSTANT,  # 边界填充模式：
                                      # - BORDER_CONSTANT（常数填充，默认）
                                      # - BORDER_REPLICATE（复制边缘像素）
                                      # - BORDER_REFLECT（镜像反射填充）
    borderValue=(0, 0, 0)            # 边界填充值（BGR三通道时为三元组）
) -> dst    # 输出变换后的图像
```


## 4 基础变换实现与代码示例  
### 4.1 图像旋转（绕任意中心点）  
#### 核心函数：`cv2.getRotationMatrix2D()`  
```python  
def rotate_image(img, center, angle, scale=1.0):
    """
    绕指定中心点旋转图像
    :param img: 输入图像（灰度图或彩色图）
    :param center: 旋转中心坐标 (x, y)
    :param angle: 旋转角度（度，逆时针为正）
    :param scale: 缩放因子（1.0表示原尺寸）
    :return: 旋转后的图像
    """
    rows, cols = img.shape[:2] if len(img.shape) == 3 else (img.shape[0], img.shape[1])
    M = cv2.getRotationMatrix2D(center, angle, scale)  # 生成2×3旋转矩阵（含平移）
    
    # 计算旋转后的图像边界（避免黑边截断）
    cos = np.abs(M[0, 0])
    sin = np.abs(M[0, 1])
    new_w = int(cols * cos + rows * sin)
    new_h = int(rows * cos + cols * sin)
    
    # 调整旋转中心到新图像中心（可选，避免偏移）
    M[0, 2] += (new_w - cols) / 2
    M[1, 2] += (new_h - rows) / 2
    
    return cv2.warpAffine(img, M, (new_w, new_h))

# 示例：绕图像中心旋转45°
img = cv2.imread("input.jpg", cv2.IMREAD_COLOR)
h, w = img.shape[:2]
center = (w // 2, h // 2)
rotated = rotate_image(img, center, 45)
```

### 4.2 图像平移  
#### 手动构造平移矩阵  
```python  
def translate_image(img, tx, ty):
    """
    平移图像
    :param img: 输入图像
    :param tx: x轴平移量（正值向右，负值向左）
    :param ty: y轴平移量（正值向下，负值向上）
    :return: 平移后的图像
    """
    M = np.float32([[1, 0, tx], [0, 1, ty]])
    # 扩展输出尺寸以容纳平移后的图像
    new_w = img.shape[1] + abs(tx)
    new_h = img.shape[0] + abs(ty)
    return cv2.warpAffine(img, M, (new_w, new_h))

# 示例：向右平移50px，向上平移30px
translated = translate_image(img, 50, -30)
```

### 4.3 图像缩放（含锚点控制）  
#### 带锚点的缩放矩阵（默认锚点为原点）  
```python  
def scale_image(img, sx, sy, anchor=(0, 0)):
    """
    按比例缩放图像，支持指定缩放锚点
    :param img: 输入图像
    :param sx: x轴缩放因子
    :param sy: y轴缩放因子
    :param anchor: 缩放锚点（默认原点，(w/2,h/2)为中心缩放）
    :return: 缩放后的图像
    """
    # 构造缩放矩阵（先缩放，后平移回锚点）
    M = np.float32([
        [sx, 0, anchor[0] * (1 - sx)],
        [0, sy, anchor[1] * (1 - sy)]
    ])
    new_w = int(img.shape[1] * sx)
    new_h = int(img.shape[0] * sy)
    return cv2.warpAffine(img, M, (new_w, new_h))

# 示例：以图像中心为锚点，宽高各缩放0.5倍
center_anchor = (img.shape[1]//2, img.shape[0]//2)
scaled = scale_image(img, 0.5, 0.5, center_anchor)
```

### 4.4 图像剪切（双向剪切实现）  
#### 复合剪切矩阵（同时x/y轴剪切）  
```python  
def shear_image(img, sh_x=0, sh_y=0):
    """
    图像剪切变换
    :param img: 输入图像
    :param sh_x: y轴方向剪切因子（x坐标影响y偏移，值越大倾斜越明显）
    :param sh_y: x轴方向剪切因子（y坐标影响x偏移，值越大倾斜越明显）
    :return: 剪切后的图像
    """
    M = np.float32([
        [1, sh_y, 0],       # x轴剪切：x' = x + sh_y * y
        [sh_x, 1, 0]        # y轴剪切：y' = y + sh_x * x
    ])
    # 计算剪切后的图像边界（避免截断）
    max_x = int(img.shape[1] + abs(sh_y * img.shape[0]))
    max_y = int(img.shape[0] + abs(sh_x * img.shape[1]))
    return cv2.warpAffine(img, M, (max_x, max_y))

# 示例：x轴剪切因子0.3，y轴剪切因子0.2
sheared = shear_image(img, sh_x=0.2, sh_y=0.3)
```


## 5 组合变换与矩阵运算  
### 5.1 变换顺序的重要性  
仿射变换矩阵遵循“右乘”顺序，即先进行的变换矩阵位于右侧：  
```python  
# 正确顺序：先旋转45°，再缩放0.5倍，最后平移(100, 50)
M_rotate = cv2.getRotationMatrix2D(center, 45, 1.0)
M_scale = np.float32([[0.5, 0, 0], [0, 0.5, 0]])
M_translate = np.float32([[1, 0, 100], [0, 1, 50]])

# 矩阵相乘顺序：M = 平移 × 缩放 × 旋转（从右到左执行）
M_combined = M_translate @ M_scale @ M_rotate  # 等价于 T·S·R·P
combined_img = cv2.warpAffine(img, M_combined, (new_width, new_height))
```

### 5.2 逆变换求解  
通过 `cv2.invertAffineTransform()` 可获取逆变换矩阵，用于坐标反推：  
```python  
M_inv = cv2.invertAffineTransform(M)  # 求M的逆矩阵
```


## 6 最佳实践与注意事项  
### 6.1 数据类型规范  
- 变换矩阵必须为 `np.float32` 类型，否则 `cv2.warpAffine()` 会抛出 `(-215:Assertion failed)` 错误。  
- 输入图像若为浮点型（如归一化后的0-1范围），需确保数据类型为 `np.float32` 或 `np.float64`。  

### 6.2 输出尺寸计算  
- 旋转/剪切后图像可能超出原尺寸，需通过几何计算（如旋转后的边界矩形）动态调整输出尺寸，避免图像被截断。  
- 平移时若希望保留完整图像，输出尺寸应至少为 `(原宽+|tx|, 原高+|ty|)`。  

### 6.3 插值方法选择  
| 场景需求    | 推荐插值方法        | 计算复杂度 | 图像质量    |
| ------- | ------------- | ----- | ------- |
| 实时处理    | INTER_NEAREST | 低     | 锯齿明显    |
| 常规缩放/旋转 | INTER_LINEAR  | 中     | 平衡质量与速度 |
| 高清图像处理  | INTER_CUBIC   | 高     | 边缘平滑    |
| 下采样（缩小） | INTER_AREA    | 中     | 抗锯齿效果好  |

### 6.4 边界填充策略  
- 处理大位移或旋转时，建议使用 `BORDER_REPLICATE` 或 `BORDER_REFLECT` 填充，避免黑色边界（`BORDER_CONSTANT`）影响视觉效果。  
- 彩色图像填充时需传入BGR三元组（如 `(255, 255, 255)` 表示白色边界）。  


## 7 数学补充：仿射变换的行列式  
变换矩阵的行列式值 $$| \mathbf{L} | = ad - bc $$ 具有重要几何意义：  
- $$ | \mathbf{L} | = 1 $$：保面积变换（如纯旋转、剪切）  
- $$ | \mathbf{L} | > 0 $$：保持空间定向（左右手坐标系不变）  
- $$ | \mathbf{L} | < 0 $$：反转空间定向（镜像变换）  
- $$ | \mathbf{L} | = 0 $$：变换为退化变换（降维，如投影到直线）  

通过行列式可快速判断变换是否为可逆变换（行列式非零则可逆）。


## 8 应用场景举例  
1. **图像配准**：通过仿射变换对齐不同视角的图像（如医学影像配准）。  
2. **目标检测预处理**：对数据集进行旋转/缩放增强，提升模型鲁棒性。  
3. **文档矫正**：对倾斜文档图像进行旋转和平移，恢复水平视角。  
4. **图像编辑**：实现图片的自由变换（如Photoshop中的“自由变换”工具）。  




