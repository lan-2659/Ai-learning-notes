# 图像透视变换(图像矫正)

### 基本知识

听名字有点熟，我们在接触过仿射变换，知道仿射变换是把一个二维坐标系转换到另一个二维坐标系的过程，转换过程坐标点的相对位置和属性不发生变换，是一个线性变换，该过程只发生旋转和平移过程。因此，一个平行四边形经过仿射变换后还是一个平行四边形。

![形状, 矩形 描述已自动生成](../images/04e2fc8243b76ebe7d89bb6d1300be02.png)

而 **透视变换** 是一种将图像从一个平面投影到另一个平面的变换方法，用于纠正图像的透视畸变（如近大远小的变形）或实现视角转换（如从斜视图转换为正视图）。其核心原理基于**射影几何**，通过矩阵运算实现平面到平面的一一映射。

 ![公路上的汽车 描述已自动生成](../images/287b73b93b9d7465c7edae2ab686bb37.png) 

​								图1



![卡通人物 中度可信度描述已自动生成](../images/2a1c7c96c0ef6d1f69257cfbdbf4c003.png) 
​								图2

如上图所示，图1在经过透视变换后得到了图2的结果，带入上面的话就是图像中的车道线（目标物体）的被观察视角从平视视角变成了俯视视角，这就是透视变换的作用。

与仿射变换一样，透视变换也有自己的**透视变换矩阵(单应性矩阵)**：
$$
\begin{array}{l l l}{{\left[\begin{array}{c}{{X}}\\{{Y}}\\{Z} \end{array}\right]=\left[\begin{array}{c c c}{{a_{11}}}&{{a_{12}}}&{{a_{13}}}\\ {{a_{21}}}&{{a_{22}}}&{{a_{23}}}\\ {{a_{31}}}&{{a_{32}}}&{{a_{33}}}\end{array}\right]*\left[\begin{array}{c}{{x}}\\{{y}}\\{{1}}\end{array}\right]}}\end{array}
$$
即
$$
X=a_{11}\cdot x+a_{12}\cdot y+a_{13}
$$

$$
Y=a_{21}\cdot x+a_{22}\cdot y+a_{23}
$$

$$
Z=a_{31}\cdot x+a_{32}\cdot y+a_{33}
$$

由此可得新的坐标的表达式为：
$$
x^{\prime}={\frac{X}{Z}}={\frac{a_{11}\cdot x+a_{12}\cdot y+a_{13}}{a_{31}\cdot x+a_{32}\cdot y+a_{33}}}
$$

$$
y^{\prime}={\frac{Y}{Z}}={\frac{a_{21}\cdot x+a_{22}\cdot y+a_{23}}{a_{31}\cdot x+a_{32}\cdot y+a_{33}}}
$$

其中x、y是原始图像点的坐标，$x^{\prime}$、$y^{\prime}$是变换后的坐标，a11，a12，…,a33则是一些旋转量和平移量



### 透视变换矩阵(单应性矩阵)的求解

为了计算单应性矩阵$H$，需要知道至少四个对应点对（即原始图像和目标图像中对应的点）。通过这些对应点对，可以建立一系列的线性方程，然后使用最小二乘法等方法来求解$H$中的各个元素。

（由于涉及三维空间，故此处不作过多介绍，会使用OpenCV中的API即可，想了解更多可以去学习**投影几何**）



### 透视变换矩阵的生成与使用

生成：

- **cv2.getPerspectiveTransform(src,dst)**
- - **该函数会返回一个透视变换矩阵**

使用：

- **cv2.warpPerspective(src, M, dsize, flags, borderMode)**
- - **该函数会返回一个经透视变换后的新图像(对原图像不影响)**

这两个API的具体使用在后续的.py文件中有详细介绍