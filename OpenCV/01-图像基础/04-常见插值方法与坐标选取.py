# OpenCv中坐标(x, y)
"""
在OpenCv中图像是以 numpy.ndarray 的形式存储的
如下图所示：（'*'代表像素）

    0 1 2 3 4 5 6 7 8 9 ————-————-————-————-> x
 0  * * * * * * * * * * * * * * * * * * * *
 1  * * * * * * * * * * * * * * * * * * * *
 2  * * * * * * * * * * * * * * * * * * * *
 3  * * * * * * * * * * * * * * * * * * * *
 4  * * * * * * * * * * * * * * * * * * * *
 5  * * * * * * * * * * * * * * * * * * * *
 6  * * * * * * * * * * * * * * * * * * * *
 7  * * * * * * * * * * * * * * * * * * * *
 8  * * * * * * * * * * * * * * * * * * * *
 9  * * * * * * * * * * * * * * * * * * * *
 |  * * * * * * * * * * * * * * * * * * * *
 |  * * * * * * * * * * * * * * * * * * * *
 |  * * * * * * * * * * * * * * * * * * * *
 |  * * * * * * * * * * * * * * * * * * * *
 V   
 y   

最左上角的'*'坐标为(0, 0)
从左上角开始，x向左为正方向，y向下为正方向

向OpenCv中的方法传递(x, y)坐标时，(x, y)坐标以上述方法为准
"""


# 最近邻插值
"""
1. 核心概念
最近邻插值是图像处理中最简单、计算速度最快的插值方法。
其核心思想是：当需要生成新像素时，直接取原图像中距离最近的像素值。
它不涉及复杂的数学计算，仅依赖位置关系，因此效率极高，但可能会导致图像边缘出现锯齿

2. 数学原理
    设原图像尺寸为 W:H, 缩放后的目标图像尺寸为 W′:H′ 则缩放比例为：
        scale_x = W / W′
        scale_y = H / H′
        
    目标图像中任意像素点 (x′, y′) 对应的原图像坐标 (x, y) 计算方式为：
        x = round(x′ * scale_x)
        y = round(y′ * scale_y)
"""


# 双线性插值
"""
1. 核心概念
双线性插值是一种基于周围四个最近像素值的图像插值方法，通过两次线性插值（水平方向和垂直方向）计算新像素值。
相较于最近邻插值，它能生成更平滑的图像，减少锯齿现象，但计算复杂度稍高。

2. 数学原理
    设原图像尺寸为 W:H, 缩放后的目标图像尺寸为 W′:H′ 则缩放比例为：
        scale_x = (W-1) / (W′-1)
        scale_y = (H-1) / (H′-1)
    注：减1是为了让目标图像的最后一个像素对应原图像的最后一个像素
        
    目标图像中任意像素点 Q′(x′, y′) 对应的原图像浮点坐标坐标 Q(x, y) 计算方式为：
        x = x′ * scale_x
        y = y′ * scale_y
    
    取浮点坐标 Q(x, y) 周围四个像素点进行加权平均(按距离算权重，距离越近权重越大)(两次水平加权，一次垂直加权):
        i = int(x)
        j = int(y)

        Q11 = (i, j)
        Q12 = (i, j+1)
        Q21 = (i+1, j)
        Q22 = (i+1, j+1)

        则这四个点与浮点坐标 Q(x, y) 的相对位置如下：

        (i, j)    x1    Q1     x2         (i+1, j)  
            Q11--------*----------------Q12
                       | y1
                       |
                       Q(x, y)
                       |
                       | 
                       | y2
                       |
                       |
                       |
            Q21--------*----------------Q22
      (i, j+1)          Q2                (i+1, j+1)

        Q1 = (x2 * Q11 + x1 * Q12) / (x2 + x1)
        Q2 = (x2 * Q21 + x1 * Q22) / (x2 + x1)

        Q = (y2 * Q1 + y1 * Q2) / (y2 + y1)

        注: x2 + x1 和 y2 + y1 的值为 1 其实可以直接省去，但是怕以后忘记，所以保留
"""


# 双三次插值
"""

"""


# 区域重采样
"""
原理：
    当缩小图像时，计算目标像素对应源图像区域的像素平均值  
    数学本质：  
        像素面积积分 → 离散形式的箱式滤波  
    特殊处理：  
        放大时退化为最近邻插值（因此不推荐用于放大）

特点：
    ⚡️ 缩小图像时速度较快  
    🟢 消除摩尔纹和锯齿  
    🔴 放大时效果差

适用场景：
    图像缩小（OpenCV推荐方法）  
    需要避免混叠（aliasing）的信号处理
"""